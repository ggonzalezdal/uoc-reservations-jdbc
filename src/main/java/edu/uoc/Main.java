package edu.uoc;import edu.uoc.dao.CustomerDao;import edu.uoc.dao.ReservationDao;import edu.uoc.dao.ReservationTableDao;import edu.uoc.dao.TableDao;import edu.uoc.db.Database;import edu.uoc.model.Customer;import edu.uoc.model.Reservation;import edu.uoc.service.ReservationService;import java.sql.Connection;import java.sql.SQLException;import java.time.LocalDateTime;import java.time.OffsetDateTime;import java.time.ZoneId;import java.time.format.DateTimeFormatter;import java.time.format.DateTimeParseException;import java.util.ArrayList;import java.util.List;import java.util.Optional;import java.util.Scanner;public class Main {    public static void main(String[] args) {        // Choose ONE mode while learning:        //runConnectionCheck();        //runDaoDemo();        runMenu();        // Quick test (optional)        //ReservationDao reservationDao = new ReservationDao();        //reservationDao.findAll().forEach(System.out::println);    }    /**     * JDBC connection diagnostics.     * Verifies env vars, driver, and DB availability.     */    private static void runConnectionCheck() {        try (Connection conn = Database.getConnection()) {            System.out.println("Connected to database!");            System.out.println("DB product   : " + conn.getMetaData().getDatabaseProductName());            System.out.println("DB version   : " + conn.getMetaData().getDatabaseProductVersion());            System.out.println("JDBC driver  : " + conn.getMetaData().getDriverName());            System.out.println("Driver ver.  : " + conn.getMetaData().getDriverVersion());        } catch (SQLException e) {            System.err.println("Connection failed!");            e.printStackTrace();        }    }    /**     * DAO playground.     * Preserves all CRUD experiments in executable form.     */    private static void runDaoDemo() {        CustomerDao dao = new CustomerDao();        // INSERT demo        long id = dao.insert("Gordon Ramsay", "+34 600 999 999", "gordon@kitchen.com");        System.out.println("Inserted customer with id = " + id);        // FIND ALL demo        System.out.println("\nAll customers:");        dao.findAll().forEach(System.out::println);        // FIND BY ID demo (Optional pattern A)        System.out.println("\nFind customer by id:");        dao.findById(id)                .ifPresentOrElse(                        System.out::println,                        () -> System.out.println("Customer not found")                );    }    /**     * Main application flow.     * Simple CLI menu using DAO methods.     */    private static void runMenu() {        CustomerDao customerDao = new CustomerDao();        ReservationDao reservationDao = new ReservationDao();        TableDao tableDao = new TableDao();        ReservationTableDao reservationTableDao = new ReservationTableDao();  // Still used for option 7        ReservationService reservationService = new ReservationService();        Scanner sc = new Scanner(System.in);        while (true) {            printMenu();            int option = readInt(sc, "Choose an option: ");            switch (option) {                case 1 -> listCustomers(customerDao);                case 2 -> addCustomer(customerDao, sc);                case 3 -> findCustomerById(customerDao, sc);                case 4 -> listReservations(reservationDao);                case 5 -> addReservation(reservationDao, sc);                case 6 -> listTables(tableDao);                case 7 -> showReservationAssignments(reservationTableDao, sc);                //case 8 -> assignTablesToReservation(tableDao, reservationTableDao, sc);                case 8 -> assignTablesToReservation(reservationService, tableDao, sc);                case 9 -> createReservationWithTables(reservationService, tableDao, sc);                case 10 -> listAvailableTables(reservationService, sc);                case 11 -> cancelReservation(reservationService, sc);                case 12 -> confirmReservation(reservationService, sc);                case 13 -> createReservationAutoAssign(reservationService, sc);                case 14 -> activateTable(tableDao, sc);                case 15 -> deactivateTable(tableDao, sc);                case 0 -> {                    System.out.println("Bye!");                    return;                }                default -> System.out.println("Invalid option. Try again.");            }            System.out.println();        }    }    // ===== Menu helpers =====    private static void printMenu() {        System.out.println("=== Main Menu ===");        System.out.println("Customers");        System.out.println("1) List customers");        System.out.println("2) Add customer");        System.out.println("3) Find customer by ID");        System.out.println();        System.out.println("Reservations");        System.out.println("4) List reservations");        System.out.println("5) Add reservation");        System.out.println();        System.out.println("Tables");        System.out.println("6) List tables");        System.out.println();        System.out.println("Assignments");        System.out.println("7) Show table assignments for reservation");        System.out.println("8) Assign tables to reservation");        System.out.println("9) Create reservation + assign tables (transaction-safe)");        System.out.println("10) List available tables for a time window");        System.out.println("11) Cancel reservation");        System.out.println("12) Confirm reservation");        System.out.println("13) Create reservation + auto-assign tables (greedy)");        System.out.println("14) Activate table");        System.out.println("15) Deactivate table");        System.out.println();        System.out.println("0) Exit");    }    private static void listCustomers(CustomerDao dao) {        List<Customer> customers = dao.findAll();        if (customers.isEmpty()) {            System.out.println("No customers found.");            return;        }        customers.forEach(System.out::println);    }    private static void addCustomer(CustomerDao dao, Scanner sc) {        System.out.print("Full name: ");        String fullName = sc.nextLine().trim();        if (fullName.isBlank()) {            System.out.println("Full name cannot be empty.");            return;        }        System.out.print("Phone (required): ");        String phone = sc.nextLine().trim();        if (phone.isBlank()) {            System.out.println("Phone cannot be empty.");            return;        }        System.out.print("Email (optional, press Enter to skip): ");        String email = sc.nextLine().trim();        if (email.isBlank()) {            email = null;        }        long newId = dao.insert(fullName, phone, email);        System.out.println("Customer inserted with id = " + newId);    }    private static void findCustomerById(CustomerDao dao, Scanner sc) {        long id = readLong(sc, "Customer ID: ");        Optional<Customer> result = dao.findById(id);        result.ifPresentOrElse(                System.out::println,                () -> System.out.println("Customer not found.")        );    }    private static void listReservations(ReservationDao dao) {        var reservations = dao.findAll();        if (reservations.isEmpty()) {            System.out.println("No reservations found.");            return;        }        reservations.forEach(System.out::println);    }    private static void addReservation(ReservationDao dao, Scanner sc) {        System.out.println("=== Add reservation ===");        long customerId = readLong(sc, "Customer ID: ");        OffsetDateTime startAt = readDateTime(sc, "Start (yyyy-MM-dd HH:mm): ");        System.out.print("End (optional, yyyy-MM-dd HH:mm, Enter to skip): ");        String endInput = sc.nextLine().trim();        OffsetDateTime endAt = null;        if (!endInput.isBlank()) {            // reuse same parsing rules as readDateTime            endAt = parseDateTime(endInput);            if (endAt == null) {                System.out.println("Invalid end format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 22:30)");                return;            }        }        int partySize = readInt(sc, "Party size: ");        System.out.print("Status [PENDING/CONFIRMED/CANCELLED/NO_SHOW] (Enter for PENDING): ");        String statusInput = sc.nextLine().trim();        String status = statusInput.isBlank() ? "PENDING" : statusInput.toUpperCase();        // Minimal validation against DB CHECK to avoid obvious runtime errors        if (!isValidStatus(status)) {            System.out.println("Invalid status. Allowed: PENDING, CONFIRMED, CANCELLED, NO_SHOW.");            return;        }        System.out.print("Notes (optional, Enter to skip): ");        String notes = sc.nextLine().trim();        if (notes.isBlank()) notes = null;        Reservation r = new Reservation(customerId, startAt, endAt, partySize, status, notes);        long id = dao.insert(r);        System.out.println("Reservation inserted with id = " + id);    }    private static void listTables(TableDao dao) {        var tables = dao.findAll();        if (tables.isEmpty()) {            System.out.println("No tables found.");            return;        }        tables.forEach(System.out::println);    }    private static void showReservationAssignments(ReservationTableDao dao, Scanner sc) {        long reservationId = readLong(sc, "Reservation ID: ");        var tableIds = dao.findTableIdsByReservationId(reservationId);        if (tableIds.isEmpty()) {            System.out.println("No tables assigned to this reservation.");            return;        }        System.out.println("Assigned table_ids: " + tableIds);    }    //private static void assignTablesToReservation(TableDao tableDao, ReservationTableDao rtDao, Scanner sc) {    private static void assignTablesToReservation(ReservationService service, TableDao tableDao, Scanner sc) {//        long reservationId = readLong(sc, "Reservation ID: ");        long reservationId = readExistingReservationIdUntilValid(sc, new ReservationDao(), "Reservation ID: ");//        System.out.print("Table codes (comma-separated, e.g. T1,T4): ");//        String input = sc.nextLine().trim();//        if (input.isBlank()) {//            System.out.println("No table codes provided.");//            return;//        }//////        String[] parts = input.split(",");//        List<Long> tableIds = new ArrayList<>();////        for (String p : parts) {//            String code = p.trim().toUpperCase();//            if (code.isBlank()) continue;////            var tableOpt = tableDao.findByCode(code);//            if (tableOpt.isEmpty()) {//                System.out.println("Unknown table code: " + code);//                return; // stop, keep it strict for now//            }//            tableIds.add(tableOpt.get().getId());//        }//        List<Long> tableIds = resolveTableIdsOrAbort(tableDao, input);//        if (tableIds == null) return;        List<Long> tableIds = readTableIdsUntilValid(                sc,                tableDao,                "Table codes (comma-separated, e.g. T1,T4): "        );        //rtDao.addAssignments(reservationId, tableIds);        //System.out.println("Assigned tables to reservation " + reservationId + ": " + input);        try {            service.assignTablesToReservationValidated(reservationId, tableIds);            System.out.println("[OK] Assigned " + tableIds.size() + " table(s) to reservation " + reservationId + ".");        } catch (IllegalArgumentException | IllegalStateException e) {            System.out.println("[ERROR] Cannot assign tables: " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void createReservationWithTables(ReservationService service, TableDao tableDao, Scanner sc) {        System.out.println("=== Create reservation + assign tables (transaction-safe) ===");        long customerId = readLong(sc, "Customer ID: ");        if (!customerExistsOrAbort(new CustomerDao(), customerId)) return;        OffsetDateTime startAt = readDateTime(sc, "Start (yyyy-MM-dd HH:mm): ");//        System.out.print("End (optional, yyyy-MM-dd HH:mm, Enter to skip -> defaults to +2 hours): ");//        String endInput = sc.nextLine().trim();//        OffsetDateTime endAt = null;//        if (!endInput.isBlank()) {//            endAt = parseDateTime(endInput);//            if (endAt == null) {//                System.out.println("Invalid end format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 22:30)");//                return;//            }//        }        OffsetDateTime endAt = readOptionalEndDateTime(                sc,                "End (optional, yyyy-MM-dd HH:mm, Enter to skip -> defaults to +2 hours): "        );        int partySize = readInt(sc, "Party size: ");//        System.out.print("Status [PENDING/CONFIRMED/CANCELLED/NO_SHOW] (Enter for PENDING): ");//        String statusInput = sc.nextLine().trim();//        String status = statusInput.isBlank() ? null : statusInput.toUpperCase();////        if (status != null && !isValidStatus(status)) {//            System.out.println("Invalid status. Allowed: PENDING, CONFIRMED, CANCELLED, NO_SHOW.");//            return;//        }        String status = readValidStatusOrDefault(                sc,                "Status [PENDING/CONFIRMED/CANCELLED/NO_SHOW] (Enter for PENDING): ",                "PENDING"        );        System.out.print("Notes (optional, Enter to skip): ");        String notes = sc.nextLine().trim();        if (notes.isBlank()) notes = null;//        System.out.print("Table codes (comma-separated, e.g. T1,T4): ");//        String input = sc.nextLine().trim();//        if (input.isBlank()) {//            System.out.println("No table codes provided.");//            return;//        }////        String[] parts = input.split(",");//        List<Long> tableIds = new ArrayList<>();////        for (String p : parts) {//            String code = p.trim().toUpperCase();//            if (code.isBlank()) continue;////            var tableOpt = tableDao.findByCode(code);//            if (tableOpt.isEmpty()) {//                System.out.println("Unknown table code: " + code);//                return; // strict for now//            }////            tableIds.add(tableOpt.get().getId());//        }//        List<Long> tableIds = resolveTableIdsOrAbort(tableDao, input);//        if (tableIds == null) return;        List<Long> tableIds = readTableIdsUntilValid(                sc,                tableDao,                "Table codes (comma-separated, e.g. T1,T4): "        );        try {            long reservationId = service.createReservationWithTables(                    customerId,                    startAt,                    endAt,     // service will default to +2h if null                    partySize,                    status,    // service will default to PENDING if null/blank                    notes,                    tableIds            );            System.out.println("[OK] Reservation created with id = " + reservationId);            System.out.println("[OK] Assigned " + tableIds.size() + " table(s).");        } catch (IllegalArgumentException | IllegalStateException e) {            // Expected business validation errors (customer missing, tables invalid, overlap)            System.out.println("[ERROR] Cannot create reservation: " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void listAvailableTables(ReservationService service, Scanner sc) {        System.out.println("=== List available tables ===");        OffsetDateTime startAt = readDateTime(sc, "Start (yyyy-MM-dd HH:mm): ");//        System.out.print("End (optional, yyyy-MM-dd HH:mm, Enter to skip -> defaults to +2 hours): ");//        String endInput = sc.nextLine().trim();////        OffsetDateTime endAt = null;//        if (!endInput.isBlank()) {//            endAt = parseDateTime(endInput);//            if (endAt == null) {//                System.out.println("Invalid end format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 22:30)");//                return;//            }//        }        OffsetDateTime endAt = readOptionalEndDateTime(                sc,                "End (optional, yyyy-MM-dd HH:mm, Enter to skip -> defaults to +2 hours): "        );        try {            var availableTables = service.listAvailableTables(startAt, endAt);            if (availableTables.isEmpty()) {                System.out.println("No available tables for that time window.");                return;            }            System.out.println("Available tables:");            availableTables.forEach(System.out::println);        } catch (IllegalArgumentException e) {            System.out.println("[ERROR] " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void cancelReservation(ReservationService service, Scanner sc) {        System.out.println("=== Cancel reservation ===");//        long reservationId = readLong(sc, "Reservation ID: ");        long reservationId = readExistingReservationIdUntilValid(                sc,                new ReservationDao(),                "Reservation ID: "        );        System.out.print("Cancellation reason (optional, Enter to skip): ");        String reason = sc.nextLine().trim();        if (reason.isBlank()) reason = null;        try {            boolean cancelledNow = service.cancelReservation(reservationId, reason);            if (cancelledNow) {                System.out.println("[OK] Reservation cancelled: " + reservationId);            } else {                System.out.println("[OK] Reservation was already cancelled: " + reservationId);            }        } catch (IllegalArgumentException e) {            System.out.println("[ERROR] " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void confirmReservation(ReservationService service, Scanner sc) {        System.out.println("=== Confirm reservation ===");//        long reservationId = readLong(sc, "Reservation ID: ");        long reservationId = readExistingReservationIdUntilValid(                sc,                new ReservationDao(),                "Reservation ID: "        );        try {            boolean confirmedNow = service.confirmReservation(reservationId);            if (confirmedNow) {                System.out.println("[OK] Reservation confirmed: " + reservationId);            } else {                System.out.println("[OK] Reservation was already confirmed: " + reservationId);            }        } catch (IllegalArgumentException | IllegalStateException e) {            System.out.println("[ERROR] " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void createReservationAutoAssign(ReservationService service, Scanner sc) {        System.out.println("=== Create reservation + auto-assign tables (greedy) ===");        long customerId = readLong(sc, "Customer ID: ");        if (!customerExistsOrAbort(new CustomerDao(), customerId)) return;        OffsetDateTime startAt = readDateTime(sc, "Start (yyyy-MM-dd HH:mm): ");//        System.out.print("End (optional, yyyy-MM-dd HH:mm, Enter to skip -> defaults to +2 hours): ");//        String endInput = sc.nextLine().trim();//        OffsetDateTime endAt = null;//        if (!endInput.isBlank()) {//            endAt = parseDateTime(endInput);//            if (endAt == null) {//                System.out.println("Invalid end format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 22:30)");//                return;//            }//        }        OffsetDateTime endAt = readOptionalEndDateTime(                sc,                "End (optional, yyyy-MM-dd HH:mm, Enter to skip -> defaults to +2 hours): "        );        int partySize = readInt(sc, "Party size: ");//        System.out.print("Status [PENDING/CONFIRMED/CANCELLED/NO_SHOW] (Enter for PENDING): ");//        String statusInput = sc.nextLine().trim();//        String status = statusInput.isBlank() ? null : statusInput.toUpperCase();////        if (status != null && !isValidStatus(status)) {//            System.out.println("Invalid status. Allowed: PENDING, CONFIRMED, CANCELLED, NO_SHOW.");//            return;//        }        String status = readValidStatusOrDefault(                sc,                "Status [PENDING/CONFIRMED/CANCELLED/NO_SHOW] (Enter for PENDING): ",                "PENDING"        );        System.out.print("Notes (optional, Enter to skip): ");        String notes = sc.nextLine().trim();        if (notes.isBlank()) notes = null;        try {            long reservationId = service.createReservationAutoAssignTables(                    customerId,                    startAt,                    endAt,                    partySize,                    status,                    notes            );            System.out.println("[OK] Reservation created with id = " + reservationId);            System.out.println("[OK] Tables auto-assigned (greedy).");        } catch (IllegalArgumentException | IllegalStateException e) {            System.out.println("[ERROR] Cannot create reservation: " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void activateTable(TableDao tableDao, Scanner sc) {        System.out.println("=== Activate table ===");        long tableId = readExistingTableIdUntilValid(sc, tableDao, "Table ID: ");        try {            boolean updated = tableDao.setActive(tableId, true);            if (updated) {                System.out.println("[OK] Table activated: " + tableId);            } else {                // Should not happen because we validated existence, but safe.                System.out.println("[ERROR] Could not activate table: " + tableId);            }        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void deactivateTable(TableDao tableDao, Scanner sc) {        System.out.println("=== Deactivate table ===");        long tableId = readExistingTableIdUntilValid(sc, tableDao, "Table ID: ");        try {            boolean updated = tableDao.setActive(tableId, false);            if (updated) {                System.out.println("[OK] Table deactivated: " + tableId);            } else {                System.out.println("[ERROR] Could not deactivate table: " + tableId);            }        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    // ===== Input helpers =====    private static int readInt(Scanner sc, String prompt) {        while (true) {            System.out.print(prompt);            String input = sc.nextLine().trim();            try {                return Integer.parseInt(input);            } catch (NumberFormatException e) {                System.out.println("Please enter a valid integer.");            }        }    }    private static long readLong(Scanner sc, String prompt) {        while (true) {            System.out.print(prompt);            String input = sc.nextLine().trim();            try {                return Long.parseLong(input);            } catch (NumberFormatException e) {                System.out.println("Please enter a valid number.");            }        }    }    private static OffsetDateTime readDateTime(Scanner sc, String prompt) {        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");        ZoneId zone = ZoneId.systemDefault();        while (true) {            System.out.print(prompt);            String input = sc.nextLine().trim();            try {                LocalDateTime ldt = LocalDateTime.parse(input, fmt);                return ldt.atZone(zone).toOffsetDateTime();            } catch (DateTimeParseException e) {                System.out.println("Invalid format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 20:30)");            }        }    }    private static OffsetDateTime parseDateTime(String input) {        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");        ZoneId zone = ZoneId.systemDefault();        try {            LocalDateTime ldt = LocalDateTime.parse(input, fmt);            return ldt.atZone(zone).toOffsetDateTime();        } catch (DateTimeParseException e) {            return null;        }    }    private static boolean isValidStatus(String status) {        return status.equals("PENDING")                || status.equals("CONFIRMED")                || status.equals("CANCELLED")                || status.equals("NO_SHOW");    }    // ===== Validation helpers =====    private static boolean customerExistsOrAbort(CustomerDao customerDao, long customerId) {        try (Connection conn = Database.getConnection()) {            if (!customerDao.existsById(conn, customerId)) {                System.out.println("[ERROR] Customer not found: " + customerId);                return false;            }            return true;        } catch (SQLException e) {            System.out.println("[ERROR] DB error while checking customer: " + e.getMessage());            return false;        }    }    private static List<Long> resolveTableIdsOrAbort(TableDao tableDao, String codesCsv) {        if (codesCsv == null || codesCsv.isBlank()) {            System.out.println("[ERROR] No table codes provided.");            return null;        }        String[] parts = codesCsv.split(",");        List<Long> tableIds = new ArrayList<>();        for (String p : parts) {            String code = p.trim().toUpperCase();            if (code.isBlank()) continue;            var tableOpt = tableDao.findByCode(code);            if (tableOpt.isEmpty()) {                System.out.println("[ERROR] Unknown table code: " + code);                return null; // fail fast            }            tableIds.add(tableOpt.get().getId());        }        if (tableIds.isEmpty()) {            System.out.println("[ERROR] No valid table codes provided.");            return null;        }        return tableIds;    }    // ===== Re-prompt helpers =====    private static OffsetDateTime readOptionalEndDateTime(Scanner sc, String prompt) {        while (true) {            System.out.print(prompt);            String endInput = sc.nextLine().trim();            if (endInput.isBlank()) {                return null; // user chose default behavior            }            OffsetDateTime endAt = parseDateTime(endInput);            if (endAt != null) {                return endAt;            }            System.out.println("[ERROR] Invalid end format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 22:30)");        }    }    private static String readValidStatusOrDefault(Scanner sc, String prompt, String defaultStatus) {        while (true) {            System.out.print(prompt);            String input = sc.nextLine().trim();            if (input.isBlank()) {                return defaultStatus;            }            String status = input.toUpperCase();            if (isValidStatus(status)) {                return status;            }            System.out.println("[ERROR] Invalid status. Allowed: PENDING, CONFIRMED, CANCELLED, NO_SHOW.");        }    }    private static List<Long> readTableIdsUntilValid(Scanner sc, TableDao tableDao, String prompt) {        while (true) {            System.out.print(prompt);            String input = sc.nextLine().trim();            List<Long> tableIds = resolveTableIdsOrAbort(tableDao, input);            if (tableIds != null) {                return tableIds;            }            // resolveTableIdsOrAbort already printed the specific error.            // We just loop to re-prompt only this field.        }    }    private static long readExistingReservationIdUntilValid(            Scanner sc,            ReservationDao reservationDao,            String prompt    ) {        while (true) {            long reservationId = readLong(sc, prompt);            if (reservationDao.existsById(reservationId)) {                return reservationId;            }            System.out.println("[ERROR] Reservation not found: " + reservationId);        }    }    private static long readExistingTableIdUntilValid(            Scanner sc,            TableDao tableDao,            String prompt    ) {        while (true) {            long tableId = readLong(sc, prompt);            if (tableDao.existsById(tableId)) {                return tableId;            }            System.out.println("[ERROR] Table not found: " + tableId);        }    }}