package edu.uoc;import edu.uoc.dao.CustomerDao;import edu.uoc.dao.ReservationDao;import edu.uoc.dao.ReservationTableDao;import edu.uoc.dao.TableDao;import edu.uoc.db.Database;import edu.uoc.model.Customer;import edu.uoc.model.Reservation;import edu.uoc.service.ReservationService;import java.sql.Connection;import java.sql.SQLException;import java.time.LocalDateTime;import java.time.OffsetDateTime;import java.time.ZoneId;import java.time.format.DateTimeFormatter;import java.time.format.DateTimeParseException;import java.util.ArrayList;import java.util.List;import java.util.Optional;import java.util.Scanner;public class Main {    public static void main(String[] args) {        // Choose ONE mode while learning:        //runConnectionCheck();        //runDaoDemo();        runMenu();        // Quick test (optional)        //ReservationDao reservationDao = new ReservationDao();        //reservationDao.findAll().forEach(System.out::println);    }    /**     * JDBC connection diagnostics.     * Verifies env vars, driver, and DB availability.     */    private static void runConnectionCheck() {        try (Connection conn = Database.getConnection()) {            System.out.println("Connected to database!");            System.out.println("DB product   : " + conn.getMetaData().getDatabaseProductName());            System.out.println("DB version   : " + conn.getMetaData().getDatabaseProductVersion());            System.out.println("JDBC driver  : " + conn.getMetaData().getDriverName());            System.out.println("Driver ver.  : " + conn.getMetaData().getDriverVersion());        } catch (SQLException e) {            System.err.println("Connection failed!");            e.printStackTrace();        }    }    /**     * DAO playground.     * Preserves all CRUD experiments in executable form.     */    private static void runDaoDemo() {        CustomerDao dao = new CustomerDao();        // INSERT demo        long id = dao.insert("Gordon Ramsay", "+34 600 999 999", "gordon@kitchen.com");        System.out.println("Inserted customer with id = " + id);        // FIND ALL demo        System.out.println("\nAll customers:");        dao.findAll().forEach(System.out::println);        // FIND BY ID demo (Optional pattern A)        System.out.println("\nFind customer by id:");        dao.findById(id)                .ifPresentOrElse(                        System.out::println,                        () -> System.out.println("Customer not found")                );    }    /**     * Main application flow.     * Simple CLI menu using DAO methods.     */    private static void runMenu() {        CustomerDao customerDao = new CustomerDao();        ReservationDao reservationDao = new ReservationDao();        TableDao tableDao = new TableDao();        ReservationTableDao reservationTableDao = new ReservationTableDao();        ReservationService reservationService = new ReservationService();        Scanner sc = new Scanner(System.in);        while (true) {            printMenu();            int option = readInt(sc, "Choose an option: ");            switch (option) {                case 1 -> listCustomers(customerDao);                case 2 -> addCustomer(customerDao, sc);                case 3 -> findCustomerById(customerDao, sc);                case 4 -> listReservations(reservationDao);                case 5 -> addReservation(reservationDao, sc);                case 6 -> listTables(tableDao);                case 7 -> showReservationAssignments(reservationTableDao, sc);                case 8 -> assignTablesToReservation(tableDao, reservationTableDao, sc);                case 9 -> createReservationWithTables(reservationService, tableDao, sc);                case 10 -> listAvailableTables(reservationService, sc);                case 11 -> cancelReservation(reservationService, sc);                case 0 -> {                    System.out.println("Bye!");                    return;                }                default -> System.out.println("Invalid option. Try again.");            }            System.out.println();        }    }    // ===== Menu helpers =====    private static void printMenu() {        System.out.println("=== Main Menu ===");        System.out.println("Customers");        System.out.println("1) List customers");        System.out.println("2) Add customer");        System.out.println("3) Find customer by ID");        System.out.println();        System.out.println("Reservations");        System.out.println("4) List reservations");        System.out.println("5) Add reservation");        System.out.println();        System.out.println("Tables");        System.out.println("6) List tables");        System.out.println();        System.out.println("Assignments");        System.out.println("7) Show table assignments for reservation");        System.out.println("8) Assign tables to reservation");        System.out.println("9) Create reservation + assign tables (transaction-safe)");        System.out.println("10) List available tables for a time window");        System.out.println("11) Cancel reservation");        System.out.println();        System.out.println("0) Exit");    }    private static void listCustomers(CustomerDao dao) {        List<Customer> customers = dao.findAll();        if (customers.isEmpty()) {            System.out.println("No customers found.");            return;        }        customers.forEach(System.out::println);    }    private static void addCustomer(CustomerDao dao, Scanner sc) {        System.out.print("Full name: ");        String fullName = sc.nextLine().trim();        if (fullName.isBlank()) {            System.out.println("Full name cannot be empty.");            return;        }        System.out.print("Phone (required): ");        String phone = sc.nextLine().trim();        if (phone.isBlank()) {            System.out.println("Phone cannot be empty.");            return;        }        System.out.print("Email (optional, press Enter to skip): ");        String email = sc.nextLine().trim();        if (email.isBlank()) {            email = null;        }        long newId = dao.insert(fullName, phone, email);        System.out.println("Customer inserted with id = " + newId);    }    private static void findCustomerById(CustomerDao dao, Scanner sc) {        long id = readLong(sc, "Customer ID: ");        Optional<Customer> result = dao.findById(id);        result.ifPresentOrElse(                System.out::println,                () -> System.out.println("Customer not found.")        );    }    private static void listReservations(ReservationDao dao) {        var reservations = dao.findAll();        if (reservations.isEmpty()) {            System.out.println("No reservations found.");            return;        }        reservations.forEach(System.out::println);    }    private static void addReservation(ReservationDao dao, Scanner sc) {        System.out.println("=== Add reservation ===");        long customerId = readLong(sc, "Customer ID: ");        OffsetDateTime startAt = readDateTime(sc, "Start (yyyy-MM-dd HH:mm): ");        System.out.print("End (optional, yyyy-MM-dd HH:mm, Enter to skip): ");        String endInput = sc.nextLine().trim();        OffsetDateTime endAt = null;        if (!endInput.isBlank()) {            // reuse same parsing rules as readDateTime            endAt = parseDateTime(endInput);            if (endAt == null) {                System.out.println("Invalid end format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 22:30)");                return;            }        }        int partySize = readInt(sc, "Party size: ");        System.out.print("Status [PENDING/CONFIRMED/CANCELLED/NO_SHOW] (Enter for PENDING): ");        String statusInput = sc.nextLine().trim();        String status = statusInput.isBlank() ? "PENDING" : statusInput.toUpperCase();        // Minimal validation against DB CHECK to avoid obvious runtime errors        if (!isValidStatus(status)) {            System.out.println("Invalid status. Allowed: PENDING, CONFIRMED, CANCELLED, NO_SHOW.");            return;        }        System.out.print("Notes (optional, Enter to skip): ");        String notes = sc.nextLine().trim();        if (notes.isBlank()) notes = null;        Reservation r = new Reservation(customerId, startAt, endAt, partySize, status, notes);        long id = dao.insert(r);        System.out.println("Reservation inserted with id = " + id);    }    private static void listTables(TableDao dao) {        var tables = dao.findAll();        if (tables.isEmpty()) {            System.out.println("No tables found.");            return;        }        tables.forEach(System.out::println);    }    private static void showReservationAssignments(ReservationTableDao dao, Scanner sc) {        long reservationId = readLong(sc, "Reservation ID: ");        var tableIds = dao.findTableIdsByReservationId(reservationId);        if (tableIds.isEmpty()) {            System.out.println("No tables assigned to this reservation.");            return;        }        System.out.println("Assigned table_ids: " + tableIds);    }    private static void assignTablesToReservation(TableDao tableDao, ReservationTableDao rtDao, Scanner sc) {        long reservationId = readLong(sc, "Reservation ID: ");        System.out.print("Table codes (comma-separated, e.g. T1,T4): ");        String input = sc.nextLine().trim();        if (input.isBlank()) {            System.out.println("No table codes provided.");            return;        }        String[] parts = input.split(",");        List<Long> tableIds = new ArrayList<>();        for (String p : parts) {            String code = p.trim().toUpperCase();            if (code.isBlank()) continue;            var tableOpt = tableDao.findByCode(code);            if (tableOpt.isEmpty()) {                System.out.println("Unknown table code: " + code);                return; // stop, keep it strict for now            }            tableIds.add(tableOpt.get().getId());        }        rtDao.addAssignments(reservationId, tableIds);        System.out.println("Assigned tables to reservation " + reservationId + ": " + input);    }    private static void createReservationWithTables(ReservationService service, TableDao tableDao, Scanner sc) {        System.out.println("=== Create reservation + assign tables (transaction-safe) ===");        long customerId = readLong(sc, "Customer ID: ");        OffsetDateTime startAt = readDateTime(sc, "Start (yyyy-MM-dd HH:mm): ");        System.out.print("End (optional, yyyy-MM-dd HH:mm, Enter to skip -> defaults to +2 hours): ");        String endInput = sc.nextLine().trim();        OffsetDateTime endAt = null;        if (!endInput.isBlank()) {            endAt = parseDateTime(endInput);            if (endAt == null) {                System.out.println("Invalid end format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 22:30)");                return;            }        }        int partySize = readInt(sc, "Party size: ");        System.out.print("Status [PENDING/CONFIRMED/CANCELLED/NO_SHOW] (Enter for PENDING): ");        String statusInput = sc.nextLine().trim();        String status = statusInput.isBlank() ? null : statusInput.toUpperCase();        if (status != null && !isValidStatus(status)) {            System.out.println("Invalid status. Allowed: PENDING, CONFIRMED, CANCELLED, NO_SHOW.");            return;        }        System.out.print("Notes (optional, Enter to skip): ");        String notes = sc.nextLine().trim();        if (notes.isBlank()) notes = null;        System.out.print("Table codes (comma-separated, e.g. T1,T4): ");        String input = sc.nextLine().trim();        if (input.isBlank()) {            System.out.println("No table codes provided.");            return;        }        String[] parts = input.split(",");        List<Long> tableIds = new ArrayList<>();        for (String p : parts) {            String code = p.trim().toUpperCase();            if (code.isBlank()) continue;            var tableOpt = tableDao.findByCode(code);            if (tableOpt.isEmpty()) {                System.out.println("Unknown table code: " + code);                return; // strict for now            }            tableIds.add(tableOpt.get().getId());        }        try {            long reservationId = service.createReservationWithTables(                    customerId,                    startAt,                    endAt,     // service will default to +2h if null                    partySize,                    status,    // service will default to PENDING if null/blank                    notes,                    tableIds            );            System.out.println("[OK] Reservation created with id = " + reservationId);            System.out.println("[OK] Assigned tables: " + input);        } catch (IllegalArgumentException | IllegalStateException e) {            // Expected business validation errors (customer missing, tables invalid, overlap)            System.out.println("[ERROR] Cannot create reservation: " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void listAvailableTables(ReservationService service, Scanner sc) {        System.out.println("=== List available tables ===");        OffsetDateTime startAt = readDateTime(sc, "Start (yyyy-MM-dd HH:mm): ");        System.out.print("End (optional, yyyy-MM-dd HH:mm, Enter to skip -> defaults to +2 hours): ");        String endInput = sc.nextLine().trim();        OffsetDateTime endAt = null;        if (!endInput.isBlank()) {            endAt = parseDateTime(endInput);            if (endAt == null) {                System.out.println("Invalid end format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 22:30)");                return;            }        }        try {            var availableTables = service.listAvailableTables(startAt, endAt);            if (availableTables.isEmpty()) {                System.out.println("No available tables for that time window.");                return;            }            System.out.println("Available tables:");            availableTables.forEach(System.out::println);        } catch (IllegalArgumentException e) {            System.out.println("[ERROR] " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    private static void cancelReservation(ReservationService service, Scanner sc) {        System.out.println("=== Cancel reservation ===");        long reservationId = readLong(sc, "Reservation ID: ");        System.out.print("Cancellation reason (optional, Enter to skip): ");        String reason = sc.nextLine().trim();        if (reason.isBlank()) reason = null;        try {            boolean cancelledNow = service.cancelReservation(reservationId, reason);            if (cancelledNow) {                System.out.println("[OK] Reservation cancelled: " + reservationId);            } else {                System.out.println("[OK] Reservation was already cancelled: " + reservationId);            }        } catch (IllegalArgumentException e) {            System.out.println("[ERROR] " + e.getMessage());        } catch (Exception e) {            System.out.println("[ERROR] Unexpected error: " + e.getMessage());        }    }    // ===== Input helpers =====    private static int readInt(Scanner sc, String prompt) {        while (true) {            System.out.print(prompt);            String input = sc.nextLine().trim();            try {                return Integer.parseInt(input);            } catch (NumberFormatException e) {                System.out.println("Please enter a valid integer.");            }        }    }    private static long readLong(Scanner sc, String prompt) {        while (true) {            System.out.print(prompt);            String input = sc.nextLine().trim();            try {                return Long.parseLong(input);            } catch (NumberFormatException e) {                System.out.println("Please enter a valid number.");            }        }    }    private static OffsetDateTime readDateTime(Scanner sc, String prompt) {        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");        ZoneId zone = ZoneId.systemDefault();        while (true) {            System.out.print(prompt);            String input = sc.nextLine().trim();            try {                LocalDateTime ldt = LocalDateTime.parse(input, fmt);                return ldt.atZone(zone).toOffsetDateTime();            } catch (DateTimeParseException e) {                System.out.println("Invalid format. Use: yyyy-MM-dd HH:mm (example: 2026-02-21 20:30)");            }        }    }    private static OffsetDateTime parseDateTime(String input) {        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");        ZoneId zone = ZoneId.systemDefault();        try {            LocalDateTime ldt = LocalDateTime.parse(input, fmt);            return ldt.atZone(zone).toOffsetDateTime();        } catch (DateTimeParseException e) {            return null;        }    }    private static boolean isValidStatus(String status) {        return status.equals("PENDING")                || status.equals("CONFIRMED")                || status.equals("CANCELLED")                || status.equals("NO_SHOW");    }}